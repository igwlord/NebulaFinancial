<!DOCTYPE html>
<html>
<head>
    <title>Diagn√≥stico Completo - Nebula Finance</title>
    <meta charset="UTF-8">
    <style>
        body { font-family: monospace; background: #0a0a0a; color: #00ff00; padding: 20px; }
        .success { color: #00ff00; }
        .error { color: #ff0000; }
        .warning { color: #ffff00; }
        .info { color: #00ffff; }
        .section { margin: 20px 0; border: 1px solid #333; padding: 15px; }
        pre { background: #1a1a1a; padding: 10px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>üöÄ DIAGN√ìSTICO COMPLETO - NEBULA FINANCE</h1>
    
    <!-- Cargar CryptoJS primero -->
    <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.2.0/crypto-js.min.js"></script>
    
    <!-- Cargar Security Utils -->
    <script src="js/utils/security.js"></script>
    
    <div id="diagnostics"></div>
    
    <script>
        const output = document.getElementById('diagnostics');
        
        function log(message, type = 'info') {
            const div = document.createElement('div');
            div.className = type;
            div.innerHTML = message;
            output.appendChild(div);
        }
        
        function runDiagnostics() {
            log('<div class="section"><h2>üîç DIAGN√ìSTICO DE DEPENDENCIAS</h2>', 'info');
            
            // Test 1: CryptoJS
            log('<h3>1Ô∏è‚É£ CryptoJS</h3>', 'info');
            if (typeof window.CryptoJS !== 'undefined') {
                log('‚úÖ CryptoJS est√° disponible globalmente', 'success');
                log(`üìã Versi√≥n detectada: ${window.CryptoJS.lib ? 'Biblioteca completa cargada' : 'Parcial'}`, 'info');
                
                // Test b√°sico de cifrado
                try {
                    const testData = 'test-data-nebula';
                    const testKey = 'test-key';
                    const encrypted = window.CryptoJS.AES.encrypt(testData, testKey).toString();
                    const decrypted = window.CryptoJS.AES.decrypt(encrypted, testKey).toString(window.CryptoJS.enc.Utf8);
                    
                    if (decrypted === testData) {
                        log('‚úÖ Cifrado/Descifrado AES funciona correctamente', 'success');
                    } else {
                        log('‚ùå Error en cifrado/descifrado AES', 'error');
                    }
                } catch (error) {
                    log(`‚ùå Error en test de cifrado: ${error.message}`, 'error');
                }
            } else {
                log('‚ùå CryptoJS NO est√° disponible', 'error');
            }
            
            // Test 2: NebulaSecurityUtils
            log('<h3>2Ô∏è‚É£ NebulaSecurityUtils</h3>', 'info');
            if (typeof window.NebulaSecurityUtils !== 'undefined') {
                log('‚úÖ NebulaSecurityUtils est√° disponible globalmente', 'success');
                
                const utils = window.NebulaSecurityUtils;
                const methods = Object.keys(utils);
                log(`üìã M√©todos disponibles: ${methods.join(', ')}`, 'info');
                
                // Test de m√©todos cr√≠ticos
                const criticalMethods = ['encryptData', 'decryptData', 'hashPassword', 'generateSecureToken'];
                criticalMethods.forEach(method => {
                    if (typeof utils[method] === 'function') {
                        log(`‚úÖ ${method}: Disponible`, 'success');
                    } else {
                        log(`‚ùå ${method}: No disponible`, 'error');
                    }
                });
                
                // Test funcional b√°sico
                try {
                    const testData = 'test-security-nebula';
                    const testPassword = 'test-password-123';
                    
                    // Test encriptaci√≥n
                    const encrypted = utils.encryptData(testData, testPassword);
                    if (encrypted && encrypted !== testData) {
                        log('‚úÖ Encriptaci√≥n funciona correctamente', 'success');
                        
                        // Test desencriptaci√≥n
                        const decrypted = utils.decryptData(encrypted, testPassword);
                        if (decrypted === testData) {
                            log('‚úÖ Desencriptaci√≥n funciona correctamente', 'success');
                        } else {
                            log('‚ùå Error en desencriptaci√≥n', 'error');
                        }
                    } else {
                        log('‚ùå Error en encriptaci√≥n', 'error');
                    }
                    
                    // Test hash de contrase√±a
                    const hashedPassword = utils.hashPassword(testPassword);
                    if (hashedPassword && hashedPassword !== testPassword) {
                        log('‚úÖ Hash de contrase√±a funciona correctamente', 'success');
                    } else {
                        log('‚ùå Error en hash de contrase√±a', 'error');
                    }
                    
                    // Test token seguro
                    const token = utils.generateSecureToken();
                    if (token && token.length > 10) {
                        log('‚úÖ Generaci√≥n de token seguro funciona correctamente', 'success');
                    } else {
                        log('‚ùå Error en generaci√≥n de token', 'error');
                    }
                    
                } catch (error) {
                    log(`‚ùå Error en tests funcionales: ${error.message}`, 'error');
                }
                
            } else {
                log('‚ùå NebulaSecurityUtils NO est√° disponible', 'error');
            }
            
            // Test 3: Orden de carga
            log('<h3>3Ô∏è‚É£ Orden de Carga</h3>', 'info');
            const scripts = Array.from(document.scripts);
            const cryptoScript = scripts.find(s => s.src.includes('crypto-js'));
            const securityScript = scripts.find(s => s.src.includes('security.js'));
            
            if (cryptoScript && securityScript) {
                const cryptoIndex = scripts.indexOf(cryptoScript);
                const securityIndex = scripts.indexOf(securityScript);
                
                if (cryptoIndex < securityIndex) {
                    log('‚úÖ CryptoJS se carga antes que security.js', 'success');
                } else {
                    log('‚ùå Orden de carga incorrecto', 'error');
                }
            } else {
                log('‚ö†Ô∏è No se pudieron encontrar los scripts en el DOM', 'warning');
            }
            
            // Test 4: Estado global del navegador
            log('<h3>4Ô∏è‚É£ Estado Global</h3>', 'info');
            const globalVars = ['CryptoJS', 'NebulaSecurityUtils'];
            globalVars.forEach(varName => {
                if (window[varName]) {
                    log(`‚úÖ window.${varName} est√° definido`, 'success');
                } else {
                    log(`‚ùå window.${varName} NO est√° definido`, 'error');
                }
            });
            
            log('</div>', 'info');
            
            // Resumen final
            log('<div class="section"><h2>üìä RESUMEN FINAL</h2>', 'info');
            const hasError = output.innerHTML.includes('‚ùå');
            const hasWarning = output.innerHTML.includes('‚ö†Ô∏è');
            
            if (!hasError) {
                log('<h3 class="success">üéâ TODOS LOS TESTS PASARON CORRECTAMENTE</h3>', 'success');
                log('La aplicaci√≥n est√° lista para funcionar sin errores de seguridad.', 'success');
            } else if (hasWarning) {
                log('<h3 class="warning">‚ö†Ô∏è HAY ADVERTENCIAS</h3>', 'warning');
                log('La aplicaci√≥n puede funcionar pero se recomienda revisar las advertencias.', 'warning');
            } else {
                log('<h3 class="error">‚ùå HAY ERRORES CR√çTICOS</h3>', 'error');
                log('La aplicaci√≥n NO funcionar√° correctamente hasta resolver estos errores.', 'error');
            }
            log('</div>', 'info');
        }
        
        // Ejecutar diagn√≥sticos despu√©s de que todo se cargue
        window.addEventListener('load', () => {
            setTimeout(runDiagnostics, 500);
        });
    </script>
</body>
</html>
